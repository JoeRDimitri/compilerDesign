prog #start 
#p rept-prog0 #reptprog0 #prog #start 
classOrImplOrFunc rept-prog0 #reptprog0 #prog #start 
classDecl #class rept-prog0 #reptprog0 #prog #start 
class id #id opt-classDecl2 { #p rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL #p #optclassdecl2 { #p rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { visibility memberDecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public #visibility memberDecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public funcDecl #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public funcHead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function #p id #id ( fParams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( #p #p id #id : type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float #type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => type #returntype #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float #type #returntype #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; visibility memberDecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public #visibility memberDecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public funcDecl #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public funcHead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function #p id #id ( fParams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( #p #p id #id : type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float #type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => type #returntype #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float #type #returntype #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; classOrImplOrFunc rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; classDecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class id #id opt-classDecl2 { #p rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL #p #optclassdecl2 { #p rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { visibility memberDecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public #visibility memberDecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public funcDecl #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public funcHead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function #p id #id ( fParams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( #p #p id #id : type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float #type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => type #returntype #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float #type #returntype #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; visibility memberDecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public #visibility memberDecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public funcDecl #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public funcHead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function #p id #id ( fParams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( #p #p id #id : type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int #type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => type #returntype #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => id #type #returntype #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; classOrImplOrFunc rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; classDecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class id #id opt-classDecl2 { #p rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa #p id #id #p rept-opt-classDecl22 #reptoptclassdecl22 #optclassdecl2 { #p rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL #reptoptclassdecl22 #optclassdecl2 { #p rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { visibility memberDecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private #visibility memberDecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attributeDecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute varDecl #attributedecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute id #id : type #p rept-varDecl3 #reptvardecl3 #vardecl ; #attributedecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float #type #p rept-varDecl3 #reptvardecl3 #vardecl ; #attributedecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float #reptvardecl3 #vardecl ; #attributedecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; visibility memberDecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private #visibility memberDecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attributeDecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute varDecl #attributedecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute id #id : type #p rept-varDecl3 #reptvardecl3 #vardecl ; #attributedecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float #type #p rept-varDecl3 #reptvardecl3 #vardecl ; #attributedecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float #reptvardecl3 #vardecl ; #attributedecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; visibility memberDecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private #visibility memberDecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attributeDecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute varDecl #attributedecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute id #id : type #p rept-varDecl3 #reptvardecl3 #vardecl ; #attributedecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int #type #p rept-varDecl3 #reptvardecl3 #vardecl ; #attributedecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int #reptvardecl3 #vardecl ; #attributedecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; visibility memberDecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public #visibility memberDecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public funcDecl #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public funcHead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function #p id #id ( fParams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( #p #p id #id : type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float #type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float #p fParamsTail #param rept-fParams4 #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , id #id : type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float #type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => type #returntype #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => id #type #returntype #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; visibility memberDecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public #visibility memberDecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public funcDecl #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public funcHead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function #p id #id ( fParams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( #p #p id #id : type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float #type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => type #returntype #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float #type #returntype #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; classOrImplOrFunc rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; classDecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class id #id opt-classDecl2 { #p rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa #p id #id #p rept-opt-classDecl22 #reptoptclassdecl22 #optclassdecl2 { #p rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL #reptoptclassdecl22 #optclassdecl2 { #p rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { visibility memberDecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private #visibility memberDecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attributeDecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute varDecl #attributedecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute id #id : type #p rept-varDecl3 #reptvardecl3 #vardecl ; #attributedecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float #type #p rept-varDecl3 #reptvardecl3 #vardecl ; #attributedecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float #reptvardecl3 #vardecl ; #attributedecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; visibility memberDecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private #visibility memberDecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attributeDecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute varDecl #attributedecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute id #id : type #p rept-varDecl3 #reptvardecl3 #vardecl ; #attributedecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float #type #p rept-varDecl3 #reptvardecl3 #vardecl ; #attributedecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float #reptvardecl3 #vardecl ; #attributedecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; visibility memberDecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private #visibility memberDecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attributeDecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute varDecl #attributedecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute id #id : type #p rept-varDecl3 #reptvardecl3 #vardecl ; #attributedecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float #type #p rept-varDecl3 #reptvardecl3 #vardecl ; #attributedecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float #reptvardecl3 #vardecl ; #attributedecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; visibility memberDecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public #visibility memberDecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public funcDecl #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public funcHead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function #p id #id ( fParams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( #p #p id #id : type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float #type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float #p fParamsTail #param rept-fParams4 #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , id #id : type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float #type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float #p fParamsTail #param rept-fParams4 #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , id #id : type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float #type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => type #returntype #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => id #type #returntype #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; visibility memberDecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public #visibility memberDecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public funcDecl #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public funcHead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function #p id #id ( fParams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( #p #p id #id : type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float #type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float #fparams ) => returnType #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => type #returntype #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float #type #returntype #funchead #funcdecl ; #funcdeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; classOrImplOrFunc rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; classDecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class id #id opt-classDecl2 { #p rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa #p id #id #p rept-opt-classDecl22 #reptoptclassdecl22 #optclassdecl2 { #p rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E #reptoptclassdecl22 #optclassdecl2 { #p rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { visibility memberDecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private #visibility memberDecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attributeDecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute varDecl #attributedecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute id #id : type #p rept-varDecl3 #reptvardecl3 #vardecl ; #attributedecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int #type #p rept-varDecl3 #reptvardecl3 #vardecl ; #attributedecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int #reptvardecl3 #vardecl ; #attributedecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; classOrImplOrFunc rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; classDecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class id #id opt-classDecl2 { #p rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa #p id #id #p rept-opt-classDecl22 #reptoptclassdecl22 #optclassdecl2 { #p rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C #reptoptclassdecl22 #optclassdecl2 { #p rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { visibility memberDecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private #visibility memberDecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attributeDecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute varDecl #attributedecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute id #id : type #p rept-varDecl3 #reptvardecl3 #vardecl ; #attributedecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int #type #p rept-varDecl3 #reptvardecl3 #vardecl ; #attributedecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int #reptvardecl3 #vardecl ; #attributedecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; classOrImplOrFunc rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; classDecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class id #id opt-classDecl2 { #p rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa #p id #id #p rept-opt-classDecl22 #reptoptclassdecl22 #optclassdecl2 { #p rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D #reptoptclassdecl22 #optclassdecl2 { #p rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { visibility memberDecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private #visibility memberDecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attributeDecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute varDecl #attributedecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute id #id : type #p rept-varDecl3 #reptvardecl3 #vardecl ; #attributedecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int #type #p rept-varDecl3 #reptvardecl3 #vardecl ; #attributedecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int #reptvardecl3 #vardecl ; #attributedecl #attributedeclfam rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; classOrImplOrFunc rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implDef #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation id #id { #p rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { funcDef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { funcHead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function #p id #id ( fParams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( #p #p id #id : type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float #type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => type #returntype #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float #type #returntype #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { #p rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return #return ( expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( arithExpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( intnum #intnum #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 #p #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } classOrImplOrFunc rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implDef #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation id #id { #p rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { funcDef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { funcHead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function #p id #id ( fParams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( #p #p id #id : type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float #type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float #p fParamsTail #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , id #id : type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float #type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => type #returntype #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => id #type #returntype #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { #p rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { localVarDecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local varDecl #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local id #id : type #p rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : id #type #p rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; rept-statement #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; id #id rept-statement2 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . rept-statement #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . id #id rept-statement2 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a #reptvariable2 #reptvariable2andid rept-statement4 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a assignOp expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := #assign expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := arithExpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A #p #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; rept-statement #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; id #id rept-statement2 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . rept-statement #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . id #id rept-statement2 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b #reptvariable2 #reptvariable2andid rept-statement4 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b assignOp expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := #assign expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := arithExpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B #p #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return #return ( expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( arithExpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion #p #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } funcDef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } funcHead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function #p id #id ( fParams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( #p #p id #id : type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float #type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => type #returntype #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float #type #returntype #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { #p rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { localVarDecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local varDecl #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local id #id : type #p rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float #type #p rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; rept-statement #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; id #id rept-statement2 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result assignOp expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := #assign expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := arithExpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := floatnum #floatnum #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 #p #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; rept-statement #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; id #id rept-statement2 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result assignOp expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := #assign expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := arithExpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a multOp factor #rightrecterm rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * #multop factor #rightrecterm rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * rept-factor #factor #rightrecterm rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * id #id rept-factor2 #factor #rightrecterm rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor #rightrecterm rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x #reptvariable2 #reptvariable2andid rept-factor4 #factor #rightrecterm rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x #factor #rightrecterm rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x addOp term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + #addop term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + factor rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + rept-factor #factor rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + id #id rept-factor2 #factor rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b #factor rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b #p #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return #return ( expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( arithExpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result #p #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } classOrImplOrFunc rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implDef #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation id #id { #p rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { funcDef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { funcHead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function #p id #id ( fParams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( #p #p id #id : type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float #type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => type #returntype #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float #type #returntype #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { #p rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { localVarDecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local varDecl #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local id #id : type #p rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float #type #p rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; rept-statement #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; id #id rept-statement2 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result assignOp expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := #assign expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := arithExpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a #p #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; rept-statement #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; id #id rept-statement2 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result assignOp expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := #assign expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := arithExpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result multOp factor #rightrecterm rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * #multop factor #rightrecterm rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * rept-factor #factor #rightrecterm rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * id #id rept-factor2 #factor #rightrecterm rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor #rightrecterm rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x #reptvariable2 #reptvariable2andid rept-factor4 #factor #rightrecterm rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x #factor #rightrecterm rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x addOp term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + #addop term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + factor rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + rept-factor #factor rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + id #id rept-factor2 #factor rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b #factor rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b #p #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; rept-statement #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; id #id rept-statement2 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result assignOp expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := #assign expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := arithExpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result multOp factor #rightrecterm rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * #multop factor #rightrecterm rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * rept-factor #factor #rightrecterm rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * id #id rept-factor2 #factor #rightrecterm rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor #rightrecterm rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x #reptvariable2 #reptvariable2andid rept-factor4 #factor #rightrecterm rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x #factor #rightrecterm rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x addOp term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + #addop term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + factor rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + rept-factor #factor rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + id #id rept-factor2 #factor rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c #factor rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c #p #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return #return ( expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( arithExpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result #p #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } funcDef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } funcHead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function #p id #id ( fParams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( #p #p id #id : type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float #type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float #p fParamsTail #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , id #id : type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float #type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float #p fParamsTail #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , id #id : type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float #type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => type #returntype #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => id #type #returntype #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { #p rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { localVarDecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local varDecl #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local id #id : type #p rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : id #type #p rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; rept-statement #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; id #id rept-statement2 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . rept-statement #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . id #id rept-statement2 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a #reptvariable2 #reptvariable2andid rept-statement4 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a assignOp expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := #assign expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := arithExpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A addOp term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + #addop term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + factor rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + rept-factor #factor rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + id #id rept-factor2 #factor rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B #factor rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B multOp factor #rightrecterm rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * #multop factor #rightrecterm rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * intnum #intnum #factor #rightrecterm rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 #p #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; rept-statement #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; id #id rept-statement2 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . rept-statement #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . id #id rept-statement2 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b #reptvariable2 #reptvariable2andid rept-statement4 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b assignOp expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := #assign expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := arithExpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B #p #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; rept-statement #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; id #id rept-statement2 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . rept-statement #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . id #id rept-statement2 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c #reptvariable2 #reptvariable2andid rept-statement4 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c assignOp expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := #assign expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := arithExpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := intnum #intnum #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 #p #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return #return ( expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( arithExpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( intnum #intnum #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 #p #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } funcDef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } funcHead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function #p id #id ( fParams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( #p #p id #id : type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float #type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float #p fParamsTail #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , id #id : type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float #type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float #p fParamsTail #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , id #id : type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float #type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => type #returntype #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => id #type #returntype #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { #p rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { localVarDecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local varDecl #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local id #id : type #p rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : id #type #p rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; rept-statement #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; id #id rept-statement2 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . rept-statement #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . id #id rept-statement2 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a #reptvariable2 #reptvariable2andid rept-statement4 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a assignOp expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := #assign expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := arithExpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A #p #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; rept-statement #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; id #id rept-statement2 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . rept-statement #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . id #id rept-statement2 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b #reptvariable2 #reptvariable2andid rept-statement4 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b assignOp expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := #assign expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := arithExpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B #p #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; rept-statement #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; id #id rept-statement2 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . rept-statement #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . id #id rept-statement2 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c #reptvariable2 #reptvariable2andid rept-statement4 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c assignOp expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := #assign expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := arithExpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C #p #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return #return ( expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( arithExpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion #p #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } classOrImplOrFunc rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } funcDef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } funcHead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function #p id #id ( fParams ) => returnType #funchead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( #p #p id #id : type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : id #type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer #fparams ) => returnType #funchead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void #void #returntype #funchead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { #p rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } classOrImplOrFunc rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } funcDef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } funcHead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function #p id #id ( fParams ) => returnType #funchead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( #p #p id #id : type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : id #type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer #fparams ) => returnType #funchead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void #void #returntype #funchead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { #p rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } classOrImplOrFunc rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } funcDef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } funcHead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function #p id #id ( fParams ) => returnType #funchead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( #p #p id #id : type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : id #type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer #p fParamsTail #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , id #id : type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : id #type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer #fparams ) => returnType #funchead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => type #returntype #funchead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => id #type #returntype #funchead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { #p rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } classOrImplOrFunc rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } funcDef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } funcHead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function #p id #id ( fParams ) => returnType #funchead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( #p #p id #id : type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : id #type #p rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer arraySize rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ arraySize2 #arraysize rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ intnum #intnum ] #arraysize rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] arraySize rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ arraySize2 #arraysize rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ intnum #intnum ] #arraysize rept-fParams3 #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] #reptfparams3 #param rept-fParams4 #fparams ) => returnType #funchead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] #fparams ) => returnType #funchead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => type #returntype #funchead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => id #type #returntype #funchead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { #p rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } classOrImplOrFunc rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } funcDef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } funcHead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function #p id #id ( fParams ) => returnType #funchead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => returnType #funchead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void #void #returntype #funchead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { #p rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { localVarDecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local varDecl #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local id #id : type #p rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : id #type #p rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; localVarDecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local varDecl #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local id #id : type #p rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : id #type #p rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; localVarDecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local varDecl #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local id #id : type #p rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : id #type #p rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; localVarDecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local varDecl #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local id #id : type #p rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : id #type #p rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; localVarDecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local varDecl #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local id #id : type #p rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : id #type #p rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; localVarDecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local varDecl #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local id #id : type #p rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float #type #p rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; localVarDecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local varDecl #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local id #id : type #p rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : id #type #p rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer arraySize rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ arraySize2 #arraysize rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ intnum #intnum ] #arraysize rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] arraySize rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ arraySize2 #arraysize rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ intnum #intnum ] #arraysize rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; localVarDecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local varDecl #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local id #id : type #p rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : id #type #p rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer arraySize rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ arraySize2 #arraysize rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ intnum #intnum ] #arraysize rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] arraySize rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ arraySize2 #arraysize rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ intnum #intnum ] #arraysize rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] arraySize rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ arraySize2 #arraysize rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ intnum #intnum ] #arraysize rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; rept-statement #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; id #id rept-statement2 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 assignOp expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := #assign expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := arithExpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . rept-factor #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . id #id rept-factor2 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( aParams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( #p expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( arithExpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( intnum #intnum #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 #p #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 aParamsTail rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , arithExpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , floatnum #floatnum #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 #p #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) #p #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; rept-statement #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; id #id rept-statement2 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 assignOp expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := #assign expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := arithExpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . rept-factor #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . id #id rept-factor2 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( aParams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( #p expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( arithExpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( sign factor #factor2 rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - #sign factor #factor2 rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - floatnum #floatnum #factor #factor2 rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 #p #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 aParamsTail rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , arithExpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , floatnum #floatnum #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 #p #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 aParamsTail rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , arithExpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , floatnum #floatnum #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 #p #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) #p #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; rept-statement #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; id #id rept-statement2 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . rept-statement #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . id #id rept-statement2 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b #reptvariable2 #reptvariable2andid rept-statement4 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b assignOp expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := #assign expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := arithExpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := intnum #intnum #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 #p #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; rept-statement #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; id #id rept-statement2 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter assignOp expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := #assign expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := arithExpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . rept-factor #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . id #id rept-factor2 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( aParams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( #p #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) #p #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; rept-statement #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; id #id rept-statement2 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( aParams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( #p #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; rept-statement #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; id #id rept-statement2 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter assignOp expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := #assign expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := arithExpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a #p #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; rept-statement #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; id #id rept-statement2 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( aParams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( #p expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( arithExpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( intnum #intnum #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 #p #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 aParamsTail rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , arithExpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , intnum #intnum #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 #p #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 aParamsTail rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , arithExpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , intnum #intnum #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 #p #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; rept-statement #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; id #id rept-statement2 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( aParams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( #p expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( arithExpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( floatnum #floatnum #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 #p #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 aParamsTail rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , arithExpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , intnum #intnum #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 #p #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; rept-statement #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; id #id rept-statement2 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i indice rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ arithExpr #indice ] rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ term rightrec-arithExpr #arithexpr #indice ] rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ factor rightrec-term #term rightrec-arithExpr #arithexpr #indice ] rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ intnum #intnum #factor rightrec-term #term rightrec-arithExpr #arithexpr #indice ] rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 #term rightrec-arithExpr #arithexpr #indice ] rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 #arithexpr #indice ] rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] assignOp expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := #assign expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := arithExpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := intnum #intnum #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 #p #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; rept-statement #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; id #id rept-statement2 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i indice rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ arithExpr #indice ] rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ term rightrec-arithExpr #arithexpr #indice ] rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ factor rightrec-term #term rightrec-arithExpr #arithexpr #indice ] rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ intnum #intnum #factor rightrec-term #term rightrec-arithExpr #arithexpr #indice ] rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 #term rightrec-arithExpr #arithexpr #indice ] rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 #arithexpr #indice ] rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] indice rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ arithExpr #indice ] rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ term rightrec-arithExpr #arithexpr #indice ] rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ factor rightrec-term #term rightrec-arithExpr #arithexpr #indice ] rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ floatnum #floatnum #factor rightrec-term #term rightrec-arithExpr #arithexpr #indice ] rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 #term rightrec-arithExpr #arithexpr #indice ] rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 #arithexpr #indice ] rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] assignOp expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := #assign expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := arithExpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := intnum #intnum #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 #p #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; rept-statement #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; id #id rept-statement2 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( aParams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( #p expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( arithExpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j #p #expr rept-aParams1 #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j #aparams #aparamsandid ) rept-statement3 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; rept-statement #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; id #id rept-statement2 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . rept-statement #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . id #id rept-statement2 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x #reptvariable2 #reptvariable2andid rept-statement4 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x assignOp expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := #assign expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := arithExpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := intnum #intnum #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 #p #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while #while ( relExpr ) #condition statBlock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( arithExpr relOp arithExpr #relexpr ) #condition statBlock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( term rightrec-arithExpr #arithexpr relOp arithExpr #relexpr ) #condition statBlock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( factor rightrec-term #term rightrec-arithExpr #arithexpr relOp arithExpr #relexpr ) #condition statBlock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr relOp arithExpr #relexpr ) #condition statBlock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr relOp arithExpr #relexpr ) #condition statBlock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr relOp arithExpr #relexpr ) #condition statBlock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr relOp arithExpr #relexpr ) #condition statBlock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter #factor rightrec-term #term rightrec-arithExpr #arithexpr relOp arithExpr #relexpr ) #condition statBlock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter #term rightrec-arithExpr #arithexpr relOp arithExpr #relexpr ) #condition statBlock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter #arithexpr relOp arithExpr #relexpr ) #condition statBlock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= #relop arithExpr #relexpr ) #condition statBlock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= term rightrec-arithExpr #arithexpr #relexpr ) #condition statBlock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= factor rightrec-term #term rightrec-arithExpr #arithexpr #relexpr ) #condition statBlock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= intnum #intnum #factor rightrec-term #term rightrec-arithExpr #arithexpr #relexpr ) #condition statBlock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 #term rightrec-arithExpr #arithexpr #relexpr ) #condition statBlock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 #arithexpr #relexpr ) #condition statBlock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { #p rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { statement rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write #write ( expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( arithExpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter #p #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; statement rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write #write ( expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( arithExpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . rept-factor #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . id #id rept-factor2 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( aParams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( #p expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( arithExpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter #p #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) #p #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; statement rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write #write ( expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( arithExpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . rept-factor #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . id #id rept-factor2 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( aParams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( #p expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( arithExpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter #term rightrec-arithExpr #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter #arithexpr expr2 #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter #p #expr rept-aParams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter ) #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter ) #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter ) #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter ) #p #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter ) ) ; #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter ) ) ; } ; #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate2 ( x : float ) => float ; } ; class POLYNOMIAL { public function evaluate ( x : float ) => float ; public function evaluate ( x : int ) => integer ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute b : int ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; class C isa E { private attribute a : int ; } ; class D isa C { private attribute b : int ; } ; class E isa D { private attribute c : int ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_functiontion : LINEAR ; new_functiontion . a := A ; new_functiontion . b := B ; return ( new_functiontion ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A + B * 3 ; new_functiontion . b := B ; new_functiontion . c := 1 ; return ( 1 ) ; } function build2 ( A : float , B : float , C : float ) => QUADRATIC { local new_functiontion : QUADRATIC ; new_functiontion . a := A ; new_functiontion . b := B ; new_functiontion . c := C ; return ( new_functiontion ) ; } } function f ( i : integer ) => void { } function f ( i : integer ) => void { } function f ( i : integer , j : integer ) => integer { } function f3 ( p1 : integer [ 2 ] [ 3 ] ) => integer { } function main ( ) => void { local a : a ; local c : C ; local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : integer ; local counter : float ; local i : integer [ 2 ] [ 3 ] ; local j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b := 1 ; counter := c . f ( ) ; undefined ( ) ; counter := a ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] := 1 ; i [ 2 ] [ 1.3 ] := 2 ; f3 ( j ) ; counter . x := 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter ) ) ; } ; } #reptprog0 #prog #start 
