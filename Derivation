prog #start 
#p rept-prog0 #reptprog0 #prog #start 
classOrImplOrFunc rept-prog0 #reptprog0 #prog #start 
classDecl #class rept-prog0 #reptprog0 #prog #start 
class id #id opt-classDecl2 { #p rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
Syntax error at (2, 18)
class POLYNOMIAL #p #optclassdecl2 { #p rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { visibility memberDecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public #visibility memberDecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public funcDecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public funcHead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function #p id #id ( fParams ) => returnType #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( id #id : type #p rept-fParams3 #reptfparams3 #p rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float #type #p rept-fParams3 #reptfparams3 #p rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float #reptfparams3 #p rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float #reptfparams4 #fparams ) => returnType #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => type #returntype #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float #type #returntype #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; classOrImplOrFunc rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; classDecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class id #id opt-classDecl2 { #p rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa #p id #id #p rept-opt-classDecl22 #reptoptclassdecl22 #optclassdecl2 { #p rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL #reptoptclassdecl22 #optclassdecl2 { #p rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { visibility memberDecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private #visibility memberDecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attributeDecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute varDecl #attributdecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute id #id : type #p rept-varDecl3 #reptvardecl3 #vardecl ; #attributdecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float #type #p rept-varDecl3 #reptvardecl3 #vardecl ; #attributdecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float #reptvardecl3 #vardecl ; #attributdecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; visibility memberDecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private #visibility memberDecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attributeDecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute varDecl #attributdecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute id #id : type #p rept-varDecl3 #reptvardecl3 #vardecl ; #attributdecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float #type #p rept-varDecl3 #reptvardecl3 #vardecl ; #attributdecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float #reptvardecl3 #vardecl ; #attributdecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; visibility memberDecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public #visibility memberDecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public funcDecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public funcHead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function #p id #id ( fParams ) => returnType #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( id #id : type #p rept-fParams3 #reptfparams3 #p rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float #type #p rept-fParams3 #reptfparams3 #p rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float #reptfparams3 #p rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float fParamsTail rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , id #id : type #p rept-fParams3 #reptfparams3 rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float #type #p rept-fParams3 #reptfparams3 rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float #reptfparams3 rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float #reptfparams4 #fparams ) => returnType #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => type #returntype #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => id #type #returntype #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; visibility memberDecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public #visibility memberDecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public funcDecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public funcHead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function #p id #id ( fParams ) => returnType #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( id #id : type #p rept-fParams3 #reptfparams3 #p rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float #type #p rept-fParams3 #reptfparams3 #p rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float #reptfparams3 #p rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float #reptfparams4 #fparams ) => returnType #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => type #returntype #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float #type #returntype #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; classOrImplOrFunc rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; classDecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class id #id opt-classDecl2 { #p rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa #p id #id #p rept-opt-classDecl22 #reptoptclassdecl22 #optclassdecl2 { #p rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL #reptoptclassdecl22 #optclassdecl2 { #p rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { visibility memberDecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private #visibility memberDecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attributeDecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute varDecl #attributdecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute id #id : type #p rept-varDecl3 #reptvardecl3 #vardecl ; #attributdecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float #type #p rept-varDecl3 #reptvardecl3 #vardecl ; #attributdecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float #reptvardecl3 #vardecl ; #attributdecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; visibility memberDecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private #visibility memberDecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attributeDecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute varDecl #attributdecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute id #id : type #p rept-varDecl3 #reptvardecl3 #vardecl ; #attributdecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float #type #p rept-varDecl3 #reptvardecl3 #vardecl ; #attributdecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float #reptvardecl3 #vardecl ; #attributdecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; visibility memberDecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private #visibility memberDecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attributeDecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute varDecl #attributdecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute id #id : type #p rept-varDecl3 #reptvardecl3 #vardecl ; #attributdecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float #type #p rept-varDecl3 #reptvardecl3 #vardecl ; #attributdecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float #reptvardecl3 #vardecl ; #attributdecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; visibility memberDecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public #visibility memberDecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public funcDecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public funcHead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function #p id #id ( fParams ) => returnType #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( id #id : type #p rept-fParams3 #reptfparams3 #p rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float #type #p rept-fParams3 #reptfparams3 #p rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float #reptfparams3 #p rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float fParamsTail rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , id #id : type #p rept-fParams3 #reptfparams3 rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float #type #p rept-fParams3 #reptfparams3 rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float #reptfparams3 rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float fParamsTail rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , id #id : type #p rept-fParams3 #reptfparams3 rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float #type #p rept-fParams3 #reptfparams3 rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float #reptfparams3 rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float #reptfparams4 #fparams ) => returnType #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => type #returntype #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => id #type #returntype #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; visibility memberDecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public #visibility memberDecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public funcDecl #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public funcHead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function #p id #id ( fParams ) => returnType #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( id #id : type #p rept-fParams3 #reptfparams3 #p rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float #type #p rept-fParams3 #reptfparams3 #p rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float #reptfparams3 #p rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float #reptfparams4 #fparams ) => returnType #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => type #returntype #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float #type #returntype #funchead #funcdecl ; #visibilityandmemberdecl rept-classDecl4 #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; #reptclassdecl4 } ; #classdecl #class rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; classOrImplOrFunc rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implDef #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation id #id { #p rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { funcDef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { funcHead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function #p id #id ( fParams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( id #id : type #p rept-fParams3 #reptfparams3 #p rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float #type #p rept-fParams3 #reptfparams3 #p rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float #reptfparams3 #p rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float #reptfparams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => type #returntype #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float #type #returntype #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { #p rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return #return ( expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( arithExpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( intnum #intnum #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 #p #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } classOrImplOrFunc rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implDef #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation id #id { #p rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { funcDef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { funcHead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function #p id #id ( fParams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( id #id : type #p rept-fParams3 #reptfparams3 #p rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float #type #p rept-fParams3 #reptfparams3 #p rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float #reptfparams3 #p rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float #reptfparams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => type #returntype #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float #type #returntype #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { #p rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { localVarDecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local varDecl #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local id #id : type #p rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float #type #p rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; rept-statement #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; id #id rept-statement2 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result assignOp expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := #assign expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := arithExpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a #p #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; rept-statement #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; id #id rept-statement2 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result assignOp expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := #assign expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := arithExpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result multOp factor #rightrecterm rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * #multop factor #rightrecterm rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * rept-factor #factor #rightrecterm rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * id #id rept-factor2 #factor #rightrecterm rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor #rightrecterm rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x #reptvariable2 #reptvariable2andid rept-factor4 #factor #rightrecterm rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x #factor #rightrecterm rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x addOp term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + #addop term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + factor rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + rept-factor #factor rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + id #id rept-factor2 #factor rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b #factor rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b #p #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; rept-statement #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; id #id rept-statement2 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result assignOp expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := #assign expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := arithExpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result multOp factor #rightrecterm rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * #multop factor #rightrecterm rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * rept-factor #factor #rightrecterm rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * id #id rept-factor2 #factor #rightrecterm rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor #rightrecterm rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x #reptvariable2 #reptvariable2andid rept-factor4 #factor #rightrecterm rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x #factor #rightrecterm rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x addOp term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + #addop term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + factor rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + rept-factor #factor rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + id #id rept-factor2 #factor rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c #factor rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c #p #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return #return ( expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( arithExpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result #p #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } funcDef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } funcHead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function #p id #id ( fParams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( id #id : type #p rept-fParams3 #reptfparams3 #p rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float #type #p rept-fParams3 #reptfparams3 #p rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float #reptfparams3 #p rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float fParamsTail rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , id #id : type #p rept-fParams3 #reptfparams3 rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float #type #p rept-fParams3 #reptfparams3 rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float #reptfparams3 rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float fParamsTail rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , id #id : type #p rept-fParams3 #reptfparams3 rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float #type #p rept-fParams3 #reptfparams3 rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float #reptfparams3 rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float #reptfparams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => type #returntype #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => id #type #returntype #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { #p rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { localVarDecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local varDecl #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local id #id : type #p rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : id #type #p rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; rept-statement #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; id #id rept-statement2 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . rept-statement #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . id #id rept-statement2 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a #reptvariable2 #reptvariable2andid rept-statement4 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a assignOp expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := #assign expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := arithExpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A #p #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; rept-statement #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; id #id rept-statement2 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . rept-statement #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . id #id rept-statement2 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b #reptvariable2 #reptvariable2andid rept-statement4 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b assignOp expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := #assign expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := arithExpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B #p #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; rept-statement #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; id #id rept-statement2 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . rept-statement #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . id #id rept-statement2 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c #reptvariable2 #reptvariable2andid rept-statement4 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c assignOp expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := #assign expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := arithExpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C #p #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return #return ( expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( arithExpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function #p #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } classOrImplOrFunc rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implDef #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation id #id { #p rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { funcDef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { funcHead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function #p id #id ( fParams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( id #id : type #p rept-fParams3 #reptfparams3 #p rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float #type #p rept-fParams3 #reptfparams3 #p rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float #reptfparams3 #p rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float fParamsTail rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , id #id : type #p rept-fParams3 #reptfparams3 rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float #type #p rept-fParams3 #reptfparams3 rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float #reptfparams3 rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float #reptfparams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => type #returntype #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => id #type #returntype #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { #p rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { localVarDecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local varDecl #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local id #id : type #p rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : id #type #p rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; rept-statement #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; id #id rept-statement2 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . rept-statement #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . id #id rept-statement2 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a #reptvariable2 #reptvariable2andid rept-statement4 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a assignOp expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := #assign expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := arithExpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A #p #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; rept-statement #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; id #id rept-statement2 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . rept-statement #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . id #id rept-statement2 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b #reptvariable2 #reptvariable2andid rept-statement4 #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b assignOp expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := #assign expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := arithExpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B #arithexpr expr2 #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B #p #expr #reptstatement4 ; #dot #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return #return ( expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( arithExpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function #p #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } funcDef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } funcHead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function #p id #id ( fParams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( id #id : type #p rept-fParams3 #reptfparams3 #p rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float #type #p rept-fParams3 #reptfparams3 #p rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float #reptfparams3 #p rept-fParams4 #reptfparams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float #reptfparams4 #fparams ) => returnType #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => type #returntype #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float #type #returntype #funchead funcBody #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { #p rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { localVarDecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local varDecl #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local id #id : type #p rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float #type #p rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; rept-statement #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; id #id rept-statement2 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result assignOp expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := #assign expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := arithExpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := floatnum #floatnum #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 #p #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; rept-statement #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; id #id rept-statement2 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result assignOp expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := #assign expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := arithExpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a multOp factor #rightrecterm rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * #multop factor #rightrecterm rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * rept-factor #factor #rightrecterm rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * id #id rept-factor2 #factor #rightrecterm rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor #rightrecterm rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x #reptvariable2 #reptvariable2andid rept-factor4 #factor #rightrecterm rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x #factor #rightrecterm rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x addOp term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + #addop term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + factor rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + rept-factor #factor rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + id #id rept-factor2 #factor rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b #factor rightrec-term #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b #term #rightrecarithexpr rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b #p #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return #return ( expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( arithExpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result #term rightrec-arithExpr #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result #arithexpr expr2 #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result #p #expr ) #freturnstatement ; rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; #reptfuncbody1 #funcbody } #funcdef rept-implDef3 #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } #reptimpldef3 #impldef } #impl rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } classOrImplOrFunc rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } funcDef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } funcHead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function #p id #id ( fParams ) => returnType #funchead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => returnType #funchead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void #void #returntype #funchead funcBody #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { #p rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { localVarDecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local varDecl #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local id #id : type #p rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : id #type #p rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; localVarDecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local varDecl #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local id #id : type #p rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : id #type #p rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; localVarDecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local varDecl #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local id #id : type #p rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int #type #p rept-varDecl3 #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int #reptvardecl3 #vardecl ; #localvardecl rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; rept-statement #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; id #id rept-statement2 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 assignOp expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := #assign expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := arithExpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . rept-factor #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . id #id rept-factor2 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( aParams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( arithExpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( term rightrec-arithExpr #arithexpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( intnum #intnum #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 #term rightrec-arithExpr #arithexpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 #arithexpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 #p #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 aParamsTail rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , expr #aparamstail rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , arithExpr expr2 #expr #aparamstail rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , term rightrec-arithExpr #arithexpr expr2 #expr #aparamstail rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #aparamstail rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , floatnum #floatnum #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #aparamstail rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 #term rightrec-arithExpr #arithexpr expr2 #expr #aparamstail rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 #arithexpr expr2 #expr #aparamstail rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 #p #expr #aparamstail rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) #p #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; rept-statement #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; id #id rept-statement2 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 assignOp expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := #assign expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := arithExpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . rept-factor #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . id #id rept-factor2 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( aParams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( arithExpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( term rightrec-arithExpr #arithexpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( sign factor #factor2 rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - #sign factor #factor2 rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - intnum #intnum #factor #factor2 rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 #term rightrec-arithExpr #arithexpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 #arithexpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 #p #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 aParamsTail rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , expr #aparamstail rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , arithExpr expr2 #expr #aparamstail rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , term rightrec-arithExpr #arithexpr expr2 #expr #aparamstail rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #aparamstail rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , intnum #intnum #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #aparamstail rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 #term rightrec-arithExpr #arithexpr expr2 #expr #aparamstail rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 #arithexpr expr2 #expr #aparamstail rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 #p #expr #aparamstail rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 aParamsTail rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , expr #aparamstail rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , arithExpr expr2 #expr #aparamstail rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , term rightrec-arithExpr #arithexpr expr2 #expr #aparamstail rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #aparamstail rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , intnum #intnum #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #aparamstail rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 #term rightrec-arithExpr #arithexpr expr2 #expr #aparamstail rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 #arithexpr expr2 #expr #aparamstail rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 #p #expr #aparamstail rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) #p #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; rept-statement #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; id #id rept-statement2 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter #p rept-variable2 #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter #reptvariable2 #reptvariable2andid rept-statement4 #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter assignOp expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := #assign expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := arithExpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := intnum #intnum #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 #term rightrec-arithExpr #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 #arithexpr expr2 #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 #p #expr #reptstatement4 ; #statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; localVarDeclOrStat rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; statement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while #while ( relExpr ) #condition statBlock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( arithExpr relOp arithExpr #relexpr ) #condition statBlock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( term rightrec-arithExpr #arithexpr relOp arithExpr #relexpr ) #condition statBlock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( factor rightrec-term #term rightrec-arithExpr #arithexpr relOp arithExpr #relexpr ) #condition statBlock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr relOp arithExpr #relexpr ) #condition statBlock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr relOp arithExpr #relexpr ) #condition statBlock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr relOp arithExpr #relexpr ) #condition statBlock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr relOp arithExpr #relexpr ) #condition statBlock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter #factor rightrec-term #term rightrec-arithExpr #arithexpr relOp arithExpr #relexpr ) #condition statBlock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter #term rightrec-arithExpr #arithexpr relOp arithExpr #relexpr ) #condition statBlock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter #arithexpr relOp arithExpr #relexpr ) #condition statBlock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= #relop arithExpr #relexpr ) #condition statBlock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= term rightrec-arithExpr #arithexpr #relexpr ) #condition statBlock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= factor rightrec-term #term rightrec-arithExpr #arithexpr #relexpr ) #condition statBlock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= intnum #intnum #factor rightrec-term #term rightrec-arithExpr #arithexpr #relexpr ) #condition statBlock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 #term rightrec-arithExpr #arithexpr #relexpr ) #condition statBlock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 #arithexpr #relexpr ) #condition statBlock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { #p rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { statement rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write #write ( expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( arithExpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . rept-factor #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . id #id rept-factor2 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 #reptvariable2 #reptvariable2andid rept-factor4 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . rept-factor #dot #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . id #id rept-factor2 #dot #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( aParams #aparamsandid ) rept-factor3 #dot #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( arithExpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( term rightrec-arithExpr #arithexpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter #term rightrec-arithExpr #arithexpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter #arithexpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter #p #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) #dot #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) #p #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; statement rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write #write ( expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( arithExpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter #p #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; statement rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write #write ( expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( arithExpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . rept-factor #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . id #id rept-factor2 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( aParams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( arithExpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( term rightrec-arithExpr #arithexpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( counter #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( counter #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( counter #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( counter #term rightrec-arithExpr #arithexpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( counter #arithexpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( counter #p #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( counter #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( counter ) #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( counter ) #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( counter ) #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( counter ) #p #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; statement rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write #write ( expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( arithExpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . rept-factor #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . id #id rept-factor2 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( aParams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( arithExpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( term rightrec-arithExpr #arithexpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( rept-factor #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( id #id rept-factor2 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter #p rept-variable2 #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter #reptvariable2 #reptvariable2andid rept-factor4 #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter #term rightrec-arithExpr #arithexpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter #arithexpr expr2 #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter #p #expr #p rept-aParams1 #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter #reptaparams1 #aparams #aparamsandid ) rept-factor3 #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter ) #dot #factor rightrec-term #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter ) #term rightrec-arithExpr #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter ) #arithexpr expr2 #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter ) #p #expr ) #writestatement ; rept-statBlock1 #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter ) ) ; #reptstatblock1 } #statblock #then ; #whilestatement rept-funcBody1 #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter ) ) ; } ; #reptfuncbody1 #funcbody } #funcdef #func rept-prog0 #reptprog0 #prog #start 
class POLYNOMIAL { public function evaluate ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public function build ( A : float , B : float ) => LINEAR ; public function evaluate ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public function build ( A : float , B : float , C : float ) => QUADRATIC ; public function evaluate ( x : float ) => float ; } ; implementation POLYNOMIAL { function evaluate ( x : float ) => float { return ( 0 ) ; } } implementation QUADRATIC { function evaluate ( x : float ) => float { local result : float ; result := a ; result := result * x + b ; result := result * x + c ; return ( result ) ; } function build ( A : float , B : float , C : float ) => QUADRATIC { local new_function : QUADRATIC ; new_function . a := A ; new_function . b := B ; new_function . c := C ; return ( new_function ) ; } } implementation LINEAR { function build ( A : float , B : float ) => LINEAR { local new_function : LINEAR ; new_function . a := A ; new_function . b := B ; return ( new_function ) ; } function evaluate ( x : float ) => float { local result : float ; result := 0.0 ; result := a * x + b ; return ( result ) ; } } function main ( ) => void { local f1 : LINEAR ; local f2 : QUADRATIC ; local counter : int ; f1 := f1 . build ( 2 , 3.5 ) ; f2 := f2 . build ( - 2 , 1 , 0 ) ; counter := 1 ; while ( counter <= 10 ) { write ( f1 . f2 . evaluate ( counter ) ) ; write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter ) ) ; } ; } #reptprog0 #prog #start 
